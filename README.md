# ScheduGator

Schedugator is a web application created with react.js, python, node.js, and SQL.
The purpose of schedugator is to allow employers to generate weekly shift schedules for part-time workers. 

## Local Search Algorithm summary
In order to create this project, the nurse-rostering problem was tackled using a modified Hill-Climbing algorithm.
This algorithm first generated an empty set of shifts, then proceeded to generate schedule states by filling each shift
with an employee. Each time a shift's assigned employee changed, a new neighbor state was generated.

## Schedule Scoring
Each time a new schedule state is generated by the local search, the schedule is scored. Schedule scoring generates 3 discrete scores: 
Hardscore, midscore, and softscore.

Hardscore represents whether the schedule is in violation of any physical, real-world constraints. 
For instance, if one person is scheduled to work two simultaneous shifts, hardscore decreases.
Any shift with a hardscore less than 0 is not physically possible, and therefore invalid.

Midscore represents whether the constraints set by the employer have been met. For instance, if any shifts in the desired workday time range are left unfilled,
they decrease the midscore. A schedule with a midscore less than 0 is physcially possible, but do not satisfy the needs of an employer.

Softscore represents whether the constraints set by a scheduled employee have been met. If an employee is scheduled during an undesired or unavailable time,
softscore decreases. A softscore less than 0 is valid. The closer to zero the softscore is, the more amenable it is to the needs of its scheduled employees.

## Step choice
Each time the local search algorithm iterates, it must select a neighbor state as the new most optimal states. Because of the three discrete scores, the state chosen can
prioritize the most important aspects of the schedule first.

First, the algorithm will only select steps that seek to maximize the hardscore. Any ties in this selection are broken by maximizing the midscore, and then the softscore
in the event of another tie.

The algorithm then seeks to maximize the midscore, while making sure never to compromise the hardscore (which should be zero if a valid schedule is to be generated)

After maximizing midscore, the algorithm attempts to find the highest softscore. The algorithm will never choose a lower scoring state as the new schedule, which
allows the algorithm to find a locally optimal schedule. This has the negative effect of being vulnerable to plateus or relatively small local optima, but has 
the positive effect of completing the search in manageable time, as opposed to searching the global set of all possible schedules.

